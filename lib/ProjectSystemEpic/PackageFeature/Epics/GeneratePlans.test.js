"use babel";
// @flow

import { Map } from "immutable";
import configureMockStore from "redux-mock-store";
import waitForActions from "redux-mock-store-await-actions";
import { createEpicMiddleware } from "redux-observable";
import { packagesRefreshed } from "../Actions/PackagesRefreshed";
import generatePlansEpic from "./GeneratePlans";

import { removeGeneratedPlans } from "../../../ExecutionControlEpic/PlanConfigurationFeature/Actions/RemoveGeneratedPlans";
import { addConsoleLogsForTask } from "../../../ExecutionControlEpic/ConsoleFeature/Actions/AddConsoleLog";
import { ConsoleLogError } from "../../../ExecutionControlEpic/ConsoleFeature/Types/types";

jest.useFakeTimers();

describe("GeneratePlans Epic", () => {
  let store;

  const fakePluginInfo = {
    tool: {
      id: "1",
      name: "toolName",
      iconUri: "toolIcon",
      uri: "file:///file",
    },
    isPackage: "package.json",
  };
  const fakePackageInfo = {
    name: "package.json",
    path: "/firstDir/package.json",
    uriPlatform: "posix",
    type: "file",
  };
  const fakeConfig = {
    name: "test1",
    value: {
      caseValue: { script: "script1", environmentVariables: [] },
      expressionValue: "run",
    },
  };
  beforeEach(() => {
    const epicGeneratePlans = createEpicMiddleware(
      generatePlansEpic(() => "XXX"),
    );
    const mockStore = configureMockStore([epicGeneratePlans]);
    store = mockStore({
      plans: Map(),
    });
  });

  it("should do nothing without generatePlansForPackage", () => {
    const fakePackage = { ...fakePackageInfo, plugin: fakePluginInfo };
    const packagesAction = packagesRefreshed(
      "/",
      [fakePackage],
      [fakePluginInfo],
    );

    store.dispatch(packagesAction);
    jest.runAllTimers();

    expect(store.getActions()).toEqual([packagesAction]);
  });

  it("should dispatch a addPlanConfig", async () => {
    const fakePlugin = {
      ...fakePluginInfo,
      generatePlansForPackage: async packagePath => [fakeConfig],
    };
    const fakePackage = { ...fakePackageInfo, plugin: fakePlugin };
    const packagesAction = packagesRefreshed("/", [fakePackage], [fakePlugin]);

    store.dispatch(packagesAction);
    jest.runAllTimers();
    await waitForActions(store, [
      packagesAction,
      removeGeneratedPlans(fakePluginInfo.tool, fakePackageInfo.path),
      {
        type: "ADD_PLAN_CONFIGURATION",
        payload: {
          id: "0",
          name: "test1",
          tool: fakePlugin.tool,
          autoGenerated: true,
          config: fakeConfig.value,
          packageInfo: fakePackage,
          pinned: false,
        },
      },
    ]);
  });

  // TODO - Remove hard-coded values
  const logErrorAction = err =>
    addConsoleLogsForTask({
      source: "Molecule",
      color: "#592b71",
      version: "0.4.0",
      severity: ConsoleLogError,
      message: `Error generating plans for toolName with package package.json: ${err}`,
      date: "XXX",
    });

  it("should log an error if generatePlansForPackage throws", async () => {
    const fakePlugin = {
      ...fakePluginInfo,
      generatePlansForPackage: packagePath => {
        throw new Error("Ouch");
      },
    };
    const fakePackage = { ...fakePackageInfo, plugin: fakePlugin };
    const packagesAction = packagesRefreshed("/", [fakePackage], [fakePlugin]);

    store.dispatch(packagesAction);
    jest.runAllTimers();
    await waitForActions(store, [packagesAction, logErrorAction("Ouch")]);
  });

  it("should log an error if generatePlansForPackage returns bad data", async () => {
    const fakePlugin = {
      ...fakePluginInfo,
      generatePlansForPackage: packagePath => {
        return 123;
      },
    };
    const fakePackage = { ...fakePackageInfo, plugin: fakePlugin };
    const packagesAction = packagesRefreshed("/", [fakePackage], [fakePlugin]);

    store.dispatch(packagesAction);
    jest.runAllTimers();
    await waitForActions(store, [
      packagesAction,
      logErrorAction("generatePlansForPackage must return an array"),
    ]);
  });
});
